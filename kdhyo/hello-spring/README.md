# [스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/)

---
## 스프링 버전 정보
### M(Milestone build)
- 완전하지 않은 기능이 포함된 버전.  
- SHAPSHOT 보다는 안정적이나 여전히 문제가 있을 수 있다.
- 기능이 완성되자마자 공개되는 편.  

### RC(Release Candidate)
- 출시 후보 버전을 의미.
- 기능이 가능하면 완전하고 안정적이어야 한다.
- 후보 버전이기 때문에 여전히 문제가 있을 수 있다.
- RC 에서의 기능들은 대부분 그대로 GA로 배포된다.

### GA(General Availability)
- 최종 릴리즈 버전을 의미.
- 기능이 완전하고, 안정적이다.

### SR(Service Release)
- Major 버전 이후에 제공되는 후속 유지보수 릴리즈 버전.

### SHAPSHOT
- 아직 개발 중인 버전.
- 언제든지 기능이 추가되고 삭제될 수 있기 때문에 가장 불안정한 버전.

---
## build.gradle 정보

### plugins
- 스프링부트 버전

### repositories
- dependencies 파일을 어디서 끌어올지를 정한다.
- 기본은 mavenCentral 여기서 끌어온다.
- mavenCentral 은 Maven 저장소를 호스팅하는 데 더 널리 사용되는 Nexus 소프트웨어의 배후 회사인 Sonatype에서 운영한다.

### dependencies
- 끌어올 라이브러리 정보

하나의 라이브러리를 끌어올 때 의존관계에 있는 모든 라이브러리들도 끌고 온다.

---
## 기본 컨트롤러 문자열 리턴 값
- 뷰 리졸버(viewResolver)가 화면을 찾아서 처리한다.
- 스프링 부트 템플릿엔진 기본 viewName 매핑
- resources:templates/+{ViewName}+.html

---
## IDE 가 아닌 콘솔로 빌드하는 방법
1. ./gradlew build
2. cd build/libs
3. java -jar hello-spring-0.0.1-SNAPSHOT.jar
4. 실행 확인

---
## 타임리프 장점
- html 파일로만 열어도 오류없이 열 수 있다.

---
## @RequestParam(value = "name", required = false)
- 쿼리스트링 값을 가져온다 ex) ?name=Spring!!
- required default 은 true 이며, false 로 변경하면 쿼리스트링이 없어도 된다.

---
## getter/setter
- 프로퍼티 접근방식이라고 하기도 함.
- 인스턴스 변수를 private 으로 선언하고 사용함.

---
## HttpMessageConverter
- 리턴 값이 'Json' 일 경우 - JsonConverter
- 리턴 값이 'String' 일 경우 - StringConverter

---

## private static Map<Long, Member> store = new HashMap<>();
- 동시성 문제가 고려되어 있지 않음, 실무에서는 ConcurrentHashMap, AtomicLong 사용 고려
- 테스트 시 순서에 상관 없이 무조건 성공이 떠야한다.
- @AfterEach 애노테이션을 통해 테스트 별로 끝날 때마다 값을 지워주는 형식을 사용

---
## 의존관계 설정(DI) 방식
- 컴포넌트 스캔과 자동 의존관계 설정 (애노테이션으로 스프링 빈 자동 등록)
  - @Component 사용
- 자바 코드로 직접 스프링 빈 등록하기
  - @Configuration + @Bean 사용

  ### 자바 코드로 직접 스프링 빈 등록하기 장점
  - 설정파일만을 바꿔치기하여 테스트 구현클래스에서 실제 구현클래스로 변경할 수 있다.
---
## 스프링 의존성 주입(DI) 3가지 방법

1. 필드주입
```
@Autowired private MemberService memberService;
```
2. 생성자 주입
```
@Autowired
public MemberService(MemberService memberService) {
this.memberService = memberService;
}
```
3. setter 주입
```
@Autowired
public void setMemberService(MemberService memberService) {
this.memberService = memberService;
}
```

- 필드 주입은 중간에 바꿔치기 할 수 없기 때문에 권장하지 않음.
- setter 주입은 캡슐화를 깨기 때문에 권장하지 않음.
- 보통 생성자 주입을 한다.

---
## @Autowired
- 빈에서 관리하는 클래스에서만 동작한다.
- 생성자가 하나일 경우에는 생략할 수 있다.

---
## @GeneratedValue(strategy = GenerationType.IDENTITY)
- 디비에서 직접 ID 를 생성하는 전략.
- 디비 별 generated by default as identity 와 같음.

---
## 스프링 쓰는 이유
- 객체지향 설계가 좋다. (그 이유는?)
  - 다형성을 활용한다.  
    인터페이스를 두고, 구현체를 쉽게 바꿀 수 있다.  
    스프링 컨테이너와 DI 덕분에 쉽게 가능 하다.  

  ### 개발-폐쇄원칙(OCP, Open-Closed Principle) (SOLID 원칙)
  - 확장에는 열려있고, 수정, 변경에는 닫혀있다.
  - 스프링 DI를 활용하면 기존 코드를 전혀 손대지 않고, 설정만으로 구현클래스를 변경할 수 있다.

---
## JdbcTemplate
- 기존 jdbc 코드의 반복된 코드들을 대부분 제거해준다. 하지만, 쿼리는 직접 작성해야한다.

  ### 이름에 Template 이 붙은 이유
  - 디자인 패턴 중 Template 패턴을 많이 활용해서 코드를 줄였기 때문

---
## JPA
- 반복 코드는 물론이고, 기본적인 SQL도 JPA가 직접 만들어서 실행해준다.
- SQL과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임을 전환할 수 있다.
- 개발 생산성을 크게 높일 수 있다.
- JPA 은 자바 표준 인터페이스이고, 구현체는 하이버네이트를 사용한다.

  ### spring.jpa.show-sql=true
  - jpa 쿼리를 콘솔로 볼 수 있다.
  
  ### spring.jpa.hibernate.ddl-auto=none
  - 테이블 생성여부

---
## JpaRepository
- interface 에서 JpaRepository 를 extends 하게되면,  
  Spring 에서 자동으로 구현체를 만들고 해당 구현체를 의존성주입을 할 수 있게 해준다.
- 스프링 빈을 자동으로 만들어서 프록시를 통해 객체를 생성해서 컨테이너에 올린다.

간단한건 스프링 데이터 JPA 를 기본으로 사용하고, 복잡한 동적 쿼리는 QueryDSL 를 활용한다.

---
## AOP(Aspect Oriented Programming)
- 공통 관심 사항(cross-cutting concern) vs 핵심 관심 사항(core concern)분리
- 공통 로직은 한 곳에서만 변경할 수 있게 된다.
- 핵심 관심 사항을 깔끔하게 관리할 수 있다.
- 원하는 적용 대상을 선택할 수 있다.

스프링 DI 기능에서 AOP 를 통해 만든 클래스를 바꿔서 주입해준다.